<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust driver for the 10-bit MAX11619 ADCs | Robins blog</title><meta name=keywords content="rust,driver,adc,max11619"><meta name=description content="In my last blog post, I described how I set up a small Rust ecosystem for the Vorago REB1 development board. This development board also has a MAX11619 10-bit ADC device by Maxim devices. I thought this was a good opportunity to develop my first device driver crate because there isn&rsquo;t one for this device yet.
The REB1 development board also has a 2K potentiometer connected directly to a channel of the ADC which makes testing convenient."><meta name=author content><link rel=canonical href=https://robamu.github.io/posts/max11619-driver-rust/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://robamu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://robamu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://robamu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://robamu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://robamu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Rust driver for the 10-bit MAX11619 ADCs"><meta property="og:description" content="In my last blog post, I described how I set up a small Rust ecosystem for the Vorago REB1 development board. This development board also has a MAX11619 10-bit ADC device by Maxim devices. I thought this was a good opportunity to develop my first device driver crate because there isn&rsquo;t one for this device yet.
The REB1 development board also has a 2K potentiometer connected directly to a channel of the ADC which makes testing convenient."><meta property="og:type" content="article"><meta property="og:url" content="https://robamu.github.io/posts/max11619-driver-rust/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-16T22:51:15+01:00"><meta property="article:modified_time" content="2023-09-04T16:35:05+02:00"><meta property="og:site_name" content="robs blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust driver for the 10-bit MAX11619 ADCs"><meta name=twitter:description content="In my last blog post, I described how I set up a small Rust ecosystem for the Vorago REB1 development board. This development board also has a MAX11619 10-bit ADC device by Maxim devices. I thought this was a good opportunity to develop my first device driver crate because there isn&rsquo;t one for this device yet.
The REB1 development board also has a 2K potentiometer connected directly to a channel of the ADC which makes testing convenient."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://robamu.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Rust driver for the 10-bit MAX11619 ADCs","item":"https://robamu.github.io/posts/max11619-driver-rust/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust driver for the 10-bit MAX11619 ADCs","name":"Rust driver for the 10-bit MAX11619 ADCs","description":"In my last blog post, I described how I set up a small Rust ecosystem for the Vorago REB1 development board. This development board also has a MAX11619 10-bit ADC device by Maxim devices. I thought this was a good opportunity to develop my first device driver crate because there isn\u0026rsquo;t one for this device yet.\nThe REB1 development board also has a 2K potentiometer connected directly to a channel of the ADC which makes testing convenient.","keywords":["rust","driver","adc","max11619"],"articleBody":"In my last blog post, I described how I set up a small Rust ecosystem for the Vorago REB1 development board. This development board also has a MAX11619 10-bit ADC device by Maxim devices. I thought this was a good opportunity to develop my first device driver crate because there isnâ€™t one for this device yet.\nThe REB1 development board also has a 2K potentiometer connected directly to a channel of the ADC which makes testing convenient.\nSetup with a Digilent Oscilloscope\nBoard schematic for ADC and Potentiometer\nFrom the schematic, I saw that the CNVST pin is not connected so I could not really test any of the ADC functions using that pin, but everything else should work.\nI used the knowledge I gained from programming type-safe APIs for the VA108xx HAL and BSP to code a type-safe API for the MAX116xx device. The ADC device has different modes and configuration options to specify the clock source and the voltage reference source. Some examples:\nUse the external SPI clock for acquisiton and conversion and use an external voltage reference Use the SPI interface to start the acquisiton but use the internal oscillator for the conversions. The End-Of-Conversion (EOC) pin is used to check whether the conversion is complete. Use an internal voltage reference which is off after acquisition, so a 65 microseconds wake-up delay becomes necessary. There are a lot other configurations, and the Rust typesystem prevents using a wrong API for a given configuration. Max116xx10Bit is now initially created as an externally clocked device with an external voltage reference. This is also a valid configuration to read the ADC on the REB1 board, as the reference is pin is tied to the system voltage.\nIf another configuration is desired, the device struct needs to be converted into a different configuration using the into_*() API common to Rust. The driver docs specify some of these functions. To achieve the second configuration shown above, one would use the into_int_clkd_int_timed_through_ser_if_with_wakeup function.\nThere are also some helper constructor functions for each ADC family derivative. Some of these derivatives have different channel numbers, and the constructors set the highest channel number correct automatically, which can prevent some errors like specifying an invalid channel number as well.\nThis is the example function to use the first shown configuration and using different API options to read the channels. The full example can be found here. Provided that a JLinkGDBServer is running, flashing the software can be done with this simple command:\ncargo run --example max11619-adc --release I also used release here because I checked the correct timing and an optimized build is best for that.\n/// Use the SPI clock as the conversion clock fn adc_example_externally_clocked(spi: SpiBase\u003cSPIB\u003e, mut delay: Delay) -\u003e ! { let mut adc = max11619_externally_clocked_no_wakeup(spi) .expect(\"Creating externally clocked MAX11619 device failed\"); if READ_MODE == ReadMode::AverageN { adc.averaging( AveragingConversions::FourConversions, AveragingResults::FourResults, ) .expect(\"Error setting up averaging register\"); } let mut cmd_buf: [u8; 32] = [0; 32]; let mut counter = 0; loop { rprintln!(\"-- Measurement {} --\", counter); match READ_MODE { ReadMode::Single =\u003e { rprintln!(\"Reading single potentiometer channel\"); let pot_val = adc .read_single_channel(\u0026mut cmd_buf, POTENTIOMETER_CHANNEL) .expect(\"Creating externally clocked MAX11619 ADC failed\"); rprintln!(\"Single channel read:\"); rprintln!(\"\\tPotentiometer value: {}\", pot_val); } ReadMode::Multiple =\u003e { let mut res_buf: [u16; 4] = [0; 4]; adc.read_multiple_channels_0_to_n( \u0026mut cmd_buf, \u0026mut res_buf.iter_mut(), POTENTIOMETER_CHANNEL, ) .expect(\"Multi-Channel read failed\"); print_res_buf(\u0026res_buf); } ReadMode::MultipleNToHighest =\u003e { let mut res_buf: [u16; 2] = [0; 2]; adc.read_multiple_channels_n_to_highest( \u0026mut cmd_buf, \u0026mut res_buf.iter_mut(), AN2_CHANNEL, ) .expect(\"Multi-Channel read failed\"); rprintln!(\"Multi channel read from 2 to 3:\"); rprintln!(\"\\tAN2 value: {}\", res_buf[0]); rprintln!(\"\\tAN3 / Potentiometer value: {}\", res_buf[1]); } ReadMode::AverageN =\u003e { rprintln!(\"Scanning and averaging not possible for externally clocked mode\"); } } counter += 1; delay.delay_ms(500); } } There is also an example mode which uses the averaging functionality of the ADC. This can be used for something like filtering a noisy signal.\nThe SpiBase struct is VA10820 specific, but any SPI instance which implements the embedded-hal can be used to instantiate an ADC struct.\nADC channel output, AN1 tied to 3.3V\nI also checked the SPI signals to make fully sure that my the HAL SPI driver was correctly functioning concerning properties like timing. To check the signals directly, I was able to multiplex some pins to gain access to the SPI signals. Unfortunately, this did not really work for the MISO line, but the received values are definitely valid: When the pontentiometer is at the lowest resistance, the full system voltage is tied to the analog channel. For a 10-bit ADC, a value close to 2 to the power of 10 (1023) makes sense here. The Digilent Oscilloscope also has a really neat decoder function to analyze common peripherals.\nADC single readout signals\nFinally, I also checked whether the timing was correctly when using a mode with a 65 us wake-up delay after initiating the conversion by sending one byte:\nADC single readout signals with wake-up delay\nGood signals, and the RTT viewer was displaying correct ADC chanel values as well!\nI really like how Rust allows library and device driver developers to write safe APIs which can prevent a lot of errors at compile time. I think this has a lot of potential for satellite software development, where it is common to forbid certain operations for different software modes. Encoding something like that at compile time would make the software a lot safer.\nIn some of our projects, we also use the MAX1227 12-bit ADCs which have a lot of similarities to the MAX116xx 10-bit devices. I might look into writing a device driver crate for those as well soon.\n","wordCount":"932","inLanguage":"en","datePublished":"2021-12-16T22:51:15+01:00","dateModified":"2023-09-04T16:35:05+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://robamu.github.io/posts/max11619-driver-rust/"},"publisher":{"@type":"Organization","name":"Robins blog","logo":{"@type":"ImageObject","url":"https://robamu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://robamu.github.io accesskey=h title="Robins blog (Alt + H)">Robins blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://robamu.github.io title=Home><span>Home</span></a></li><li><a href=https://robamu.github.io/about title=About><span>About</span></a></li><li><a href=https://robamu.github.io/contact title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Rust driver for the 10-bit MAX11619 ADCs</h1><div class=post-meta><span title='2021-12-16 22:51:15 +0100 +0100'>December 16, 2021</span></div></header><div class=post-content><p>In my <a href=https://robamu.github.io/post/rust-ecosystem/>last blog post</a>, I described how I set up a
small Rust ecosystem for the Vorago REB1 development board. This development board also
has a MAX11619 10-bit ADC device by Maxim devices. I thought this was a good opportunity
to develop my first device driver crate because there isn&rsquo;t one for this device yet.</p><p>The REB1 development board also has a 2K potentiometer connected directly to a channel of the ADC
which makes testing convenient.</p><center><figure><img loading=lazy src=/img/max11619-driver/setup-rotated.jpg alt="Setup with a Digilent Oscilloscope"><figcaption><p>Setup with a Digilent Oscilloscope</p></figcaption></figure></center><center><figure><img loading=lazy src=/img/max11619-driver/pot-schem.png alt="Board schematic for ADC and Potentiometer"><figcaption><p>Board schematic for ADC and Potentiometer</p></figcaption></figure></center><p>From the schematic, I saw that the CNVST pin is not connected so I could not really test
any of the ADC functions using that pin, but everything else should work.</p><p>I used the knowledge I gained from programming type-safe APIs for the VA108xx HAL and BSP to
code a type-safe API for the MAX116xx device. The ADC device has different modes and configuration
options to specify the clock source and the voltage reference source. Some examples:</p><ol><li>Use the external SPI clock for acquisiton and conversion and use an external voltage reference</li><li>Use the SPI interface to start the acquisiton but use the internal oscillator for the conversions.
The End-Of-Conversion (EOC) pin is used to check whether the conversion is complete.
Use an internal voltage reference which is off after acquisition, so a 65 microseconds wake-up
delay becomes necessary.</li></ol><p>There are a lot other configurations, and the Rust typesystem prevents using a wrong API for a
given configuration. <a href=https://docs.rs/max116xx-10bit/latest/max116xx_10bit/struct.Max116xx10Bit.html><code>Max116xx10Bit</code></a>
is now initially created as an externally clocked device with an external voltage reference.
This is also a valid configuration to read the ADC on the REB1 board,
as the reference is pin is tied to the system voltage.</p><p>If another configuration is desired, the device struct needs to be converted into a different
configuration using the <code>into_*()</code> API common to Rust. The <a href=https://docs.rs/max116xx-10bit/latest/max116xx_10bit/>driver docs</a>
specify some of these functions. To achieve the second configuration shown above, one would
use the <a href=https://docs.rs/max116xx-10bit/latest/max116xx_10bit/struct.Max116xx10Bit.html#method.into_int_clkd_int_timed_through_ser_if_with_wakeup><code>into_int_clkd_int_timed_through_ser_if_with_wakeup</code></a>
function.</p><p>There are also some helper constructor functions for each ADC family derivative. Some of these
derivatives have different channel numbers, and the constructors set the highest channel number
correct automatically, which can prevent some errors like specifying an invalid channel number
as well.</p><p>This is the example function to use the first shown configuration and using different API
options to read the channels. The full example can be found
<a href=https://egit.irs.uni-stuttgart.de/rust/vorago-reb1/src/branch/main/examples/max11619-adc.rs>here</a>.
Provided that a <code>JLinkGDBServer</code> is running, flashing the software can be done with this simple
command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cargo run --example max11619-adc --release
</span></span></code></pre></div><p>I also used <code>release</code> here because I checked the correct timing and an optimized build is best for
that.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rs data-lang=rs><span class=line><span class=cl><span class=sd>/// Use the SPI clock as the conversion clock
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>fn</span> <span class=nf>adc_example_externally_clocked</span><span class=p>(</span><span class=n>spi</span>: <span class=nc>SpiBase</span><span class=o>&lt;</span><span class=no>SPIB</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>delay</span>: <span class=nc>Delay</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>!</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>adc</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>max11619_externally_clocked_no_wakeup</span><span class=p>(</span><span class=n>spi</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;Creating externally clocked MAX11619 device failed&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=no>READ_MODE</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>ReadMode</span>::<span class=n>AverageN</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>adc</span><span class=p>.</span><span class=n>averaging</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>AveragingConversions</span>::<span class=n>FourConversions</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>AveragingResults</span>::<span class=n>FourResults</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;Error setting up averaging register&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>cmd_buf</span>: <span class=p>[</span><span class=kt>u8</span><span class=p>;</span><span class=w> </span><span class=mi>32</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=mi>32</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>counter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;-- Measurement {} --&#34;</span><span class=p>,</span><span class=w> </span><span class=n>counter</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=no>READ_MODE</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ReadMode</span>::<span class=n>Single</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;Reading single potentiometer channel&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>pot_val</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>adc</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=n>read_single_channel</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>cmd_buf</span><span class=p>,</span><span class=w> </span><span class=no>POTENTIOMETER_CHANNEL</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;Creating externally clocked MAX11619 ADC failed&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;Single channel read:&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>Potentiometer value: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>pot_val</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ReadMode</span>::<span class=n>Multiple</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>res_buf</span>: <span class=p>[</span><span class=kt>u16</span><span class=p>;</span><span class=w> </span><span class=mi>4</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=mi>4</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>adc</span><span class=p>.</span><span class=n>read_multiple_channels_0_to_n</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>cmd_buf</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>res_buf</span><span class=p>.</span><span class=n>iter_mut</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=no>POTENTIOMETER_CHANNEL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;Multi-Channel read failed&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>print_res_buf</span><span class=p>(</span><span class=o>&amp;</span><span class=n>res_buf</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ReadMode</span>::<span class=n>MultipleNToHighest</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>res_buf</span>: <span class=p>[</span><span class=kt>u16</span><span class=p>;</span><span class=w> </span><span class=mi>2</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=mi>2</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>adc</span><span class=p>.</span><span class=n>read_multiple_channels_n_to_highest</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>cmd_buf</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>res_buf</span><span class=p>.</span><span class=n>iter_mut</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=no>AN2_CHANNEL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;Multi-Channel read failed&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;Multi channel read from 2 to 3:&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>AN2 value: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>res_buf</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>AN3 / Potentiometer value: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>res_buf</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ReadMode</span>::<span class=n>AverageN</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;Scanning and averaging not possible for externally clocked mode&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>counter</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>delay</span><span class=p>.</span><span class=n>delay_ms</span><span class=p>(</span><span class=mi>500</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>There is also an example mode which uses the averaging functionality of the ADC. This can be used
for something like filtering a noisy signal.</p><p>The <code>SpiBase&lt;SPIB></code> struct is VA10820 specific, but any SPI instance which implements the
<a href=https://docs.rs/embedded-hal/latest/embedded_hal/><code>embedded-hal</code></a> can be used to
instantiate an ADC struct.</p><center><figure><img loading=lazy src=/gif/max11619-driver/vor-pot.gif alt="Operating the potentiometer"></figure></center><center><figure><img loading=lazy src=/gif/max11619-driver/vor-rtt.gif alt="ADC channel output"><figcaption><p>ADC channel output, AN1 tied to 3.3V</p></figcaption></figure></center><p>I also checked the SPI signals to make fully sure that my the HAL SPI driver was correctly
functioning concerning properties like timing. To check the signals directly, I was able to
multiplex some pins to gain access to the SPI signals. Unfortunately, this did not really work for
the MISO line, but the received values are
definitely valid: When the pontentiometer is at the lowest resistance, the full system voltage
is tied to the analog channel. For a 10-bit ADC, a value close to 2 to the power of 10 (1023)
makes sense here. The Digilent Oscilloscope also has a really neat decoder function
to analyze common peripherals.</p><center><figure><img loading=lazy src=/img/max11619-driver/adc-single-read.png alt="ADC single read signal"><figcaption><p>ADC single readout signals</p></figcaption></figure></center><p>Finally, I also checked whether the timing was correctly when using a mode with a 65 us
wake-up delay after initiating the conversion by sending one byte:</p><center><figure><img loading=lazy src=/img/max11619-driver/adc-with-delay.png alt="ADC single readout signals with wake-up delay"><figcaption><p>ADC single readout signals with wake-up delay</p></figcaption></figure></center><p>Good signals, and the RTT viewer was displaying correct ADC chanel values as well!</p><p>I really like how Rust allows library and device driver developers to write safe APIs which can
prevent a lot of errors at compile time. I think this has a lot of potential for satellite
software development, where it is common to forbid certain operations for different software modes.
Encoding something like that at compile time would make the software a lot safer.</p><p>In some of our projects, we also use the <a href=https://www.maximintegrated.com/en/products/analog/data-converters/analog-to-digital-converters/MAX1227.html>MAX1227 12-bit ADCs</a>
which have a lot of similarities to the MAX116xx 10-bit devices. I might look into writing
a device driver crate for those as well soon.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://robamu.github.io/tags/rust/>rust</a></li><li><a href=https://robamu.github.io/tags/driver/>driver</a></li><li><a href=https://robamu.github.io/tags/adc/>adc</a></li><li><a href=https://robamu.github.io/tags/max11619/>max11619</a></li></ul></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-robamu-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2023 <a href=https://robamu.github.io>Robins blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>