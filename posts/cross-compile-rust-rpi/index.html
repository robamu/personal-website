<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cross-Compile and Debug Rust Applications for the Raspberry Pi | Robins blog</title><meta name=keywords content="rust,cross-compile,vscode,cli,raspberrypi"><meta name=description content="After exploring Rust for smaller bare-metal systems like Cortex-M based microcontrollers, I am trying to learn using Rust when using a Linux runtime. The most common example for this is the Raspberry Pi, but there are a lot of other boards out there which support Embedded Linux, for example the Beagle Bone Black or Xilinx hybrid CPU / FPGA solutions like the Zynq 7020.
Embedded Linux Boards: Raspberry Pi
Image Source"><meta name=author content><link rel=canonical href=https://robamu.github.io/posts/cross-compile-rust-rpi/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://robamu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://robamu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://robamu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://robamu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://robamu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Cross-Compile and Debug Rust Applications for the Raspberry Pi"><meta property="og:description" content="After exploring Rust for smaller bare-metal systems like Cortex-M based microcontrollers, I am trying to learn using Rust when using a Linux runtime. The most common example for this is the Raspberry Pi, but there are a lot of other boards out there which support Embedded Linux, for example the Beagle Bone Black or Xilinx hybrid CPU / FPGA solutions like the Zynq 7020.
Embedded Linux Boards: Raspberry Pi
Image Source"><meta property="og:type" content="article"><meta property="og:url" content="https://robamu.github.io/posts/cross-compile-rust-rpi/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-27T12:31:51+01:00"><meta property="article:modified_time" content="2023-09-04T16:35:05+02:00"><meta property="og:site_name" content="robs blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cross-Compile and Debug Rust Applications for the Raspberry Pi"><meta name=twitter:description content="After exploring Rust for smaller bare-metal systems like Cortex-M based microcontrollers, I am trying to learn using Rust when using a Linux runtime. The most common example for this is the Raspberry Pi, but there are a lot of other boards out there which support Embedded Linux, for example the Beagle Bone Black or Xilinx hybrid CPU / FPGA solutions like the Zynq 7020.
Embedded Linux Boards: Raspberry Pi
Image Source"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://robamu.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Cross-Compile and Debug Rust Applications for the Raspberry Pi","item":"https://robamu.github.io/posts/cross-compile-rust-rpi/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Cross-Compile and Debug Rust Applications for the Raspberry Pi","name":"Cross-Compile and Debug Rust Applications for the Raspberry Pi","description":"After exploring Rust for smaller bare-metal systems like Cortex-M based microcontrollers, I am trying to learn using Rust when using a Linux runtime. The most common example for this is the Raspberry Pi, but there are a lot of other boards out there which support Embedded Linux, for example the Beagle Bone Black or Xilinx hybrid CPU / FPGA solutions like the Zynq 7020.\nEmbedded Linux Boards: Raspberry Pi\nImage Source","keywords":["rust","cross-compile","vscode","cli","raspberrypi"],"articleBody":"After exploring Rust for smaller bare-metal systems like Cortex-M based microcontrollers, I am trying to learn using Rust when using a Linux runtime. The most common example for this is the Raspberry Pi, but there are a lot of other boards out there which support Embedded Linux, for example the Beagle Bone Black or Xilinx hybrid CPU / FPGA solutions like the Zynq 7020.\nEmbedded Linux Boards: Raspberry Pi\nImage Source\nI am especially interested in the potential of Rust to develop more complex applications and allow remote development on Linux boards. All of this generally requires cross-compiling. For most use-cases and simpler projects, compiling and running the applications on the Linux boards directly is a lot simpler then the effort of setting up a cross-compiling environment on a host machine.\nSome Background Information If you’re only interested in the result and on how to quickly cross-develop applications for your Linux board, go to the next section.\nMy experiences when developing something like satellite software for an Embedded Linux Software are the following:\nEven though there is a Linux runtime, it might not support compiling applications on the board directly. For example, the Q7S used in one of our projects has a root file system limit of 32 MB, so it does not even contain something like header files. There is generally one monolithic software written in C or C++ and which contains all the application logic. It contains most of the dependencies, for example on libraries for a certain device like a Star Tracker. This means the compilation times are long. Even if the Linux boards support compilation, compiling the primary software on the board becomes unfeasable. There are only 1-2 of the On-Board Computers available. For example, one is a Flight Model which remains packaged until satellite asembly while the other one is the Engineering Model which has to stay in the clean room. Allowing convenient development requires remote deployment of the application. Otherwise, one would have to go into the cleanroom for every small test or change to the software. The software is complex and debugging can become complex too. Printouts and LEDs are not sufficient anymore to debug the software, a full debugger is required additionally. For that reason, convenient cross-compilation and debugging are very important for me when considering Rust as an alternative to C/C++ on systems like the Q7S. I have only found bits and pieces in the Internet on how to properly do these tasks. Therefore, I have created a template repository which gathers all those bits and pieces into one package. I specifically targeted debugging with the command line and with VS Code as those tools are most commonly used in Rust development from what I have seen so far. The instrutions provided here have been tested on Linux (Ubuntu 21.04) and Windows 10, but I really recommend to use a Linux development hosted when developing anything for an Embedded Linux board.\nCross-Building a Rust application for the Raspberry Pi The instructions here are based on this excellent guide.\nClone the template repository first:\ngit clone https://github.com/robamu-org/rpi-rs-crosscompile.git You can also use the template functionality of GitHub to create your own custom repository. Cross-Building an application for the Raspberry Pi still requires a C/C++ cross-toolchain to compile Rust with an ARM linker. Make sure to download a suitable cross-compiler. Most of the automation performed by the repository is done in a Python script, so it is recommended to install Python as well.\nMake sure you can call it from the command line\nLinux:\n[Raspberry Pi 4] rmueller@power-pinguin:~/Rust/rpi-rs-crosscompile(main)$ python3 --version Python 3.9.7 Windows:\nRobin@DESKTOP-7KSTH01 MSYS ~/Documents/Rust/rpi-rs-crosscompile (main) $ py --version Python 3.9.0 You need to install scp and ssh for the Python script to work. There are different ways to do this, for example by installing Puttty or by installing these tools with MinGW64.\nSetting up the Raspberry Pi There are different ways to avoid having to retype the password everytime when tranferring an application to the Raspberry Pi or running an application remotely. On Linux, you can use sshpass for this.\nThe most easiest way and the one I recommend is to install your SSH key on the Raspberry Pi with ssh-copy-id. This works on Linux and Windows. You can follow the steps specified here to do this.\nAnother way is to use a SSH key file by supplying the -f SSHFILE flag to the bld-deploy-remote.py application in your .cargo/config.toml or as an environmental variable SSHPASS with the -e flag.\nSetup Linux You can create a cross-compiler built with crosstool-ng from here. There is one available for the Raspberry Pi 3 and the Raspberry Pi 4.\nFollowing command should get the job done, assuming you installed the cross-compiler shown above into the $HOME/x-tools folder:\nexport PATH=$PATH:\"$HOME/x-tools/armv8-rpi4-linux-gnueabihf/bin\" You can also put this in a script named rpi4-path.sh and source it with . rpi4-path.sh or your can put it in your .bashrc file to add it to $PATH permanently.\nTest with armv8-rpi4-linux-gnueabihf-gcc --version:\n[Raspberry Pi 4] rmueller@power-pinguin:~/Rust$ armv8-rpi4-linux-gnueabihf-gcc --version armv8-rpi4-linux-gnueabihf-gcc (crosstool-NG 1.24.0.390_62e9db2) 8.5.0 Copyright (C) 2018 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Proceed with the generic setup.\nSetup Windows It is recommended to install the cross-toolchain provided by SysProgs.\nAdd the binary path of your installed cross-toolchain for your path.\nYou can add the toolchain binary path to your system environmental variables permanently, for example like shown here:\nWindows Environmental Variables Example\nIf you use git bash, you can also use the Linux way shown above. Test with arm-linux-gnueabihf-gcc --version:\nC:\\Users\\Robin\\Documents\\Rust\\rpi-rs-crosscompile [main ≡]\u003e arm-linux-gnueabihf-gcc --version arm-linux-gnueabihf-gcc.exe (Raspbian 8.3.0-6+rpi1) 8.3.0 Copyright (C) 2018 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Proceed with the generic setup.\nGeneric Setup Now you are ready to build the first application for the Raspberry Pi. The .cargo/def-config.toml file is a template for a Cargo configuration to perform flashing conveniently. Copy it to .cargo/config.toml first:\ncd .cargo cp def-config.toml config.toml Then open the config.toml with a text editor of your choice and select the correct linker first, for example with armv8-rpi4-linux-gnueabihf-gcc on Linux or arm-linux-gnueabihf-gcc on Windows:\n# If you use a different cross-compiler, adapt this flag accordingly. # linker = \"armv8-rpi4-linux-gnueabihf-gcc\" # linker = \"arm-linux-gnueabihf-gcc\" # linker = \"arm-none-linux-gnueabihf-gcc\" Then select the correct runner to run the application instead of debugging it. For Windows, select a runner using py.\nLinux:\n# Requires Python3 installation. Takes care of transferring and running the application # to the Raspberry Pi # runner = \"py bld-deploy-remote.py -t -r --source\" runner = \"python3 bld-deploy-remote.py -t -r --source\" ... # runner = \"py bld-deploy-remote.py -t -d --source\" # runner = \"python3 bld-deploy-remote.py -t -d --source\" ... # runner = \"py bld-deploy-remote.py -t -d -s --gdb arm-linux-gnueabihf-gdb --source\" # runner = \"python3 bld-deploy-remote.py -t -d --source\" Windows:\n# Requires Python3 installation. Takes care of transferring and running the application # to the Raspberry Pi runner = \"py bld-deploy-remote.py -t -r --source\" # runner = \"python3 bld-deploy-remote.py -t -r --source\" ... # runner = \"py bld-deploy-remote.py -t -d --source\" # runner = \"python3 bld-deploy-remote.py -t -d --source\" ... # runner = \"py bld-deploy-remote.py -t -d -s --gdb arm-linux-gnueabihf-gdb --source\" # runner = \"python3 bld-deploy-remote.py -t -d --source\" Finally select the correct builder depending on whether you have a Raspberry Pi 0/1 or a Raspberry Pi 2/3/4\nBuilding the application Everything should be ready to build the application. Simply use cargo build.\nRunning the application Everything should be ready to run the application remotely now. Running the application is very simple now: Use cargo run, which will also build the application automatically:\nLinux:\n[Raspberry Pi 4] rmueller@power-pinguin:~/Rust/rpi-rs-crosscompile(main)$ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `python3 bld-deploy-remote.py -t -r --source target/armv7-unknown-linux-gnueabihf/debug/rpi-rs-crosscompile` Running transfer command: sshpass scp target/armv7-unknown-linux-gnueabihf/debug/rpi-rs-crosscompile pi@raspberrypi.local:\"/tmp/rpi-rs-crosscompile\" Running target application: sshpass ssh pi@raspberrypi.local /tmp/rpi-rs-crosscompile __________________________ \u003c Hello fellow Rustaceans! \u003e -------------------------- \\ \\ _~^~^~_ \\) / o o \\ (/ '_ - _' / '-----' \\ Windows:\nC:\\Users\\Robin\\Documents\\Rust\\rpi-rs-crosscompile [main ≡]\u003e cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.01s Running `python3 bld-deploy-remote.py -t -r --source target\\armv7-unknown-linux-gnueabihf\\debug\\rpi-rs-crosscompile` Running transfer command: scp target\\armv7-unknown-linux-gnueabihf\\debug\\rpi-rs-crosscompile pi@raspberrypi.local:\"/tmp/rpi-rs-crosscompile\" Warning: Permanently added the ED25519 host key for IP address '...' to the list of known hosts. rpi-rs-crosscompile 100% 4448KB 10.2MB/s 00:00 Running target application: ssh pi@raspberrypi.local /tmp/rpi-rs-crosscompile Warning: Permanently added the ED25519 host key for IP address '...' to the list of known hosts. __________________________ \u003c Hello fellow Rustaceans! \u003e -------------------------- \\ \\ _~^~^~_ \\) / o o \\ (/ '_ - _' / '-----' \\ As you can see, all commands executed by the Python scripts are shown as well.\nDebugging the application on the Command Line You can switch to the debugging configuration by changing the runner accordingly\nLinux:\n# Requires Python3 installation. Takes care of transferring and running the application # to the Raspberry Pi # runner = \"py bld-deploy-remote.py -t -r --source\" # runner = \"python3 bld-deploy-remote.py -t -r --source\" ... # runner = \"py bld-deploy-remote.py -t -d --source\" # runner = \"python3 bld-deploy-remote.py -t -d --source\" ... # runner = \"py bld-deploy-remote.py -t -d -s --gdb arm-linux-gnueabihf-gdb --source\" runner = \"python3 bld-deploy-remote.py -t -d --source\" Console output:\n[Raspberry Pi 4] rmueller@power-pinguin:~/Rust/rpi-rs-crosscompile(main)$ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `python3 bld-deploy-remote.py -t -d -s --source target/armv7-unknown-linux-gnueabihf/debug/rpi-rs-crosscompile` Running transfer command: sshpass scp target/armv7-unknown-linux-gnueabihf/debug/rpi-rs-crosscompile pi@raspberrypi.local:\"/tmp/rpi-rs-crosscompile\" Running debug command: sshpass ssh -f -L 17777:localhost:17777 pi@raspberrypi.local \"sh -c 'killall -q gdbserver; gdbserver *:17777 /tmp/rpi-rs-crosscompile'\" Process /tmp/rpi-rs-crosscompile created; pid = 7343 Listening on port 17777 Running start command: gdb-multiarch -q -x gdb.gdb target/armv7-unknown-linux-gnueabihf/debug/rpi-rs-crosscompile Reading symbols from target/armv7-unknown-linux-gnueabihf/debug/rpi-rs-crosscompile... warning: Missing auto-load script at offset 0 in section .debug_gdb_scripts of file /home/rmueller/Rust/rpi-rs-crosscompile/target/armv7-unknown-linux-gnueabihf/debug/rpi-rs-crosscompile. Use `info auto-load python-scripts [REGEXP]` to list them. Remote debugging from host 127.0.0.1 Reading /lib/ld-linux-armhf.so.3 from remote target... warning: File transfers from remote targets can be slow. Use \"set sysroot\" to access files locally instead. Reading /lib/ld-linux-armhf.so.3 from remote target... ... 0xb6fcea30 in ?? () from target:/lib/ld-linux-armhf.so.3 Breakpoint 1 at 0x40ce70: main. (2 locations) Reading /usr/lib/arm-linux-gnueabihf/libarmmem-v7l.so from remote target... ... Breakpoint 1, 0x0040cf48 in main () (gdb) c Continuing. Breakpoint 1, rpi_rs_crosscompile::main () at src/main.rs:5 5 let out = b\"Hello fellow Rustaceans!\"; (gdb) c Continuing. __________________________ \u003c Hello fellow Rustaceans! \u003e -------------------------- \\ \\ _~^~^~_ \\) / o o \\ (/ '_ - _' / '-----' \\ Child exited with status 0 [Inferior 1 (process 7343) exited normally] (gdb) Windows:\n# Requires Python3 installation. Takes care of transferring and running the application # to the Raspberry Pi runner = \"py bld-deploy-remote.py -t -r --source\" # runner = \"python3 bld-deploy-remote.py -t -r --source\" ... # runner = \"py bld-deploy-remote.py -t -d --source\" # runner = \"python3 bld-deploy-remote.py -t -d --source\" ... runner = \"py bld-deploy-remote.py -t -d -s --gdb arm-linux-gnueabihf-gdb --source\" # runner = \"python3 bld-deploy-remote.py -t -d --source\" Now, you can use cargo run like before, but this time the Python helper program will start a GDB server on the Pi and then launch a GDB application locally to debug the program.\nConsole Output, using git bash here with scp and ssh installed via MinGW64:\nRobin@DESKTOP-7KSTH01 MSYS ~/Documents/Rust/rpi-rs-crosscompile (main) $ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.01s Running `py bld-deploy-remote.py -t -d -s --gdb arm-linux-gnueabihf-gdb --source 'target\\armv7-unknown-linux-gnueabihf\\debug\\rpi-rs-crosscompile'` Running transfer command: scp target\\armv7-unknown-linux-gnueabihf\\debug\\rpi-rs-crosscompile pi@raspberrypi.local:\"/tmp/rpi-rs-crosscompile\" Enter passphrase for key '/c/Users/Robin/.ssh/id_rsa': target\\armv7-unknown-linux-gnueabihf\\debug\\rpi-rs-crosscompile 100% 4448KB 5.4MB/s 00:00 Running debug command: ssh -f -L 17777:localhost:17777 pi@raspberrypi.local \"sh -c 'killall -q gdbserver; gdbserver *:17777 /tmp/rpi-rs-crosscompile'\" Enter passphrase for key '/c/Users/Robin/.ssh/id_rsa': Process /tmp/rpi-rs-crosscompile created; pid = 29621 Listening on port 17777 Running start command: arm-linux-gnueabihf-gdb -q -x gdb.gdb target\\armv7-unknown-linux-gnueabihf\\debug\\rpi-rs-crosscompile Reading symbols from target\\armv7-unknown-linux-gnueabihf\\debug\\rpi-rs-crosscompile...done. warning: Unsupported auto-load script at offset 0 in section .debug_gdb_scripts of file C:\\Users\\Robin\\Documents\\Rust\\rpi-rs-crosscompile\\target\\armv7-unknown-linux-gnueabihf\\debug\\rpi-rs-crosscompile. Use `info auto-load python-scripts [REGEXP]` to list them. Remote debugging from host 127.0.0.1 0xb6fcea30 in ?? () from c:\\sysgcc\\raspberry\\arm-linux-gnueabihf\\sysroot/lib/ld-linux-armhf.so.3 Breakpoint 1 at 0x40a7e4 Breakpoint 1, 0x0040a7e4 in main () (gdb) b 6 Breakpoint 2 at 0x40a718: file src\\main.rs, line 6. (gdb) c Continuing. Breakpoint 2, rpi_rs_crosscompile::main () at src\\main.rs:6 6 let width = 24; (gdb) s 8 let mut writer = BufWriter::new(stdout()); (gdb) c Continuing. __________________________ \u003c Hello fellow Rustaceans! \u003e -------------------------- \\ \\ _~^~^~_ \\) / o o \\ (/ '_ - _' / '-----' \\ Child exited with status 0 [Inferior 1 (process 29621) exited normally] (gdb) Debugging the application with VS Code and CodeLLDB I think the best debugging experience is still provided by GUI tools like Eclipse or VS Code. The following examples are shown for Linux. The second one should work for Windows as well, but I had issues getting the first configuration to work on Windows.\nGDB server started by VS Code Unfortunately, I have not found a way to get the debug output produced by an application when starting the GDB server with VS code. Feel free to investigate how this could be solved using VS Code tasks.\nYou can simply select and run the Remote Debugging With Server configuration in VS Code. The result should look something like the following:\nDebugging with VS Code with GDB Server started by VS Code\nGDB server started externally The only difference is that the GDB server is now started in an external shell instance, which also allows to see debug output produced by the application. Configuring .cargo/config.toml correctly allows simply using cargo run to start the GDB server:\n# Requires Python3 installation. Takes care of transferring and running the application # to the Raspberry Pi # runner = \"py bld-deploy-remote.py -t -r --source\" # runner = \"python3 bld-deploy-remote.py -t -r --source\" ... # runner = \"py bld-deploy-remote.py -t -d --source\" runner = \"python3 bld-deploy-remote.py -t -d --source\" ... # runner = \"py bld-deploy-remote.py -t -d -s --gdb arm-linux-gnueabihf-gdb --source\" # runner = \"python3 bld-deploy-remote.py -t -d --source\" After using cargo run, you can run the Remote Debugging External Server configuration in VS Code. The result should look something like the following:\nDebugging with VS Code with externally started GDB server\nUnder the hood If you’re interested how exactly this is done in VS Code, you can have a look at the launch.json and tasks.json provided in the template repository.\nThese generally call the bld-deploy-remote.py script, which can be found here. This script automates one to all of the following steps which are generally required to deploy and debug a cross-compiled application:\nBuild the application. When using a Cargo runner, Cargo will take care of this step Transfer the application to the Raspberry Pi using the -t flag. The default destination is the /tmp folder, but this can be customized with the --dest flag Start the gdbserver on the Raspberry Pi. The script also sets up port forwarding on the port 17777 so that the development host can simply connect to localhost:17777 Start the GDB application to debug the software Using Python instead of a shell script to perform these steps provides a little bit more flexiblity and portability in my opinion. It also makes it easier to adapt the script to custom requirements, because Python has the most easiest and most readable syntax of all automation tools I have worked with.\nThis script can also be easily ported to other Embedded Linux board by tweaking the DEFAULT_* parameters found at the top of the Python script.\nRoom for Improvements I have not really looked into how tools like cross could be used to simplify this process. I think some steps might become easier but using cross also requires docker. I think the ways to run and deploy cross-compiled software shown here are sufficient for most use-cases. I might try out cross in the future though.\n","wordCount":"2616","inLanguage":"en","datePublished":"2021-12-27T12:31:51+01:00","dateModified":"2023-09-04T16:35:05+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://robamu.github.io/posts/cross-compile-rust-rpi/"},"publisher":{"@type":"Organization","name":"Robins blog","logo":{"@type":"ImageObject","url":"https://robamu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://robamu.github.io accesskey=h title="Robins blog (Alt + H)">Robins blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://robamu.github.io title=Home><span>Home</span></a></li><li><a href=https://robamu.github.io/about title=About><span>About</span></a></li><li><a href=https://robamu.github.io/contact title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Cross-Compile and Debug Rust Applications for the Raspberry Pi</h1><div class=post-meta><span title='2021-12-27 12:31:51 +0100 +0100'>December 27, 2021</span></div></header><div class=post-content><p>After exploring Rust for smaller bare-metal systems like Cortex-M based microcontrollers, I am
trying to learn using Rust when using a Linux runtime. The most common example for this is the
<a href=https://www.raspberrypi.org/>Raspberry Pi</a>, but there are a lot of other boards out there
which support Embedded Linux, for example the <a href=https://beagleboard.org/black>Beagle Bone Black</a> or
Xilinx hybrid CPU / FPGA solutions like the
<a href=https://www.xilinx.com/products/silicon-devices/soc/zynq-7000.html>Zynq 7020</a>.</p><center><figure><img loading=lazy src=/img/rpi-rs-crosscompile/RPI.jpg alt="Embedded Linux Boards: Raspberry Pi"><figcaption><p>Embedded Linux Boards: Raspberry Pi</p></figcaption></figure></center><p><a href=https://en.wikipedia.org/wiki/Raspberry_Pi#/media/File:Raspberry_Pi_4_Model_B_-_Side.jpg>Image Source</a></p><p>I am especially interested in the potential of Rust to develop more complex applications and allow
remote development on Linux boards. All of this generally requires cross-compiling. For most
use-cases and simpler projects, compiling and running the applications on the Linux boards directly
is a lot simpler then the effort of setting up a cross-compiling environment on a host machine.</p><h2 id=some-background-information>Some Background Information<a hidden class=anchor aria-hidden=true href=#some-background-information>#</a></h2><p>If you&rsquo;re only interested in the result and on how to quickly cross-develop applications for your
Linux board, go to the <a href=#crossbuild>next section</a>.</p><p>My experiences when developing something like satellite software for an Embedded Linux Software
are the following:</p><ol><li>Even though there is a Linux runtime, it might not support compiling
applications on the board directly. For example, the
<a href=https://xiphos.com/products/q7-processor/>Q7S</a> used in one of our
projects has a root file system limit of 32 MB, so it does not even
contain something like header files.</li><li>There is generally one monolithic software written in C or C++ and which
contains all the application logic. It contains most of the dependencies,
for example on libraries for a certain device like a Star Tracker. This means
the compilation times are long. Even if the Linux boards support
compilation, compiling the primary software on the board becomes unfeasable.</li><li>There are only 1-2 of the On-Board Computers available. For example, one is a
Flight Model which remains packaged until satellite asembly while the other one is the
Engineering Model which has to stay in the clean room. Allowing convenient development
requires remote deployment of the application. Otherwise, one would have to go
into the cleanroom for every small test or change to the software.</li><li>The software is complex and debugging can become complex too. Printouts and LEDs
are not sufficient anymore to debug the software, a full debugger is required additionally.</li></ol><p>For that reason, convenient cross-compilation and debugging are very important for me when
considering Rust as an alternative to C/C++ on systems like the
<a href=https://xiphos.com/products/q7-processor/>Q7S</a>.
I have only found bits and pieces in the Internet on how to properly do these tasks. Therefore, I
have created a <a href=https://github.com/robamu-org/rpi-rs-crosscompile>template repository</a> which
gathers all those bits and pieces into one package.
I specifically targeted debugging with the command line and with VS Code as those tools are most
commonly used in Rust development from what I have seen so far.
The instrutions provided here have been tested on Linux (Ubuntu 21.04) and Windows 10, but I really
recommend to use a Linux development hosted when developing anything for an Embedded Linux board.</p><h2 id=a-namecrossbuilda--cross-building-a-rust-application-for-the-raspberry-pi><a name=crossbuild></a> Cross-Building a Rust application for the Raspberry Pi<a hidden class=anchor aria-hidden=true href=#a-namecrossbuilda--cross-building-a-rust-application-for-the-raspberry-pi>#</a></h2><p>The instructions here are based on
<a href=https://chacin.dev/blog/cross-compiling-rust-for-the-raspberry-pi/>this excellent guide</a>.</p><p>Clone the template repository first:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>git clone https://github.com/robamu-org/rpi-rs-crosscompile.git
</span></span></code></pre></div><p>You can also use the template functionality of GitHub to create your own custom repository.
Cross-Building an application for the Raspberry Pi still requires a C/C++ cross-toolchain to compile
Rust with an ARM linker.
Make sure to download a suitable cross-compiler. Most of the automation
performed by the repository is done in a Python script, so it is recommended
to <a href=https://www.python.org/downloads/>install Python</a> as well.</p><p>Make sure you can call it from the command line</p><p><strong>Linux</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=go>[Raspberry Pi 4] rmueller@power-pinguin:~/Rust/rpi-rs-crosscompile(main)$ python3 --version
</span></span></span><span class=line><span class=cl><span class=go>Python 3.9.7
</span></span></span></code></pre></div><p><strong>Windows</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=go>Robin@DESKTOP-7KSTH01 MSYS ~/Documents/Rust/rpi-rs-crosscompile (main)
</span></span></span><span class=line><span class=cl><span class=go></span><span class=gp>$</span> py --version
</span></span><span class=line><span class=cl><span class=go>Python 3.9.0
</span></span></span></code></pre></div><p>You need to install <code>scp</code> and <code>ssh</code> for the Python script to work. There are different ways to
do this, for example by installing Puttty or by installing these tools with MinGW64.</p><h3 id=setting-up-the-raspberry-pi>Setting up the Raspberry Pi<a hidden class=anchor aria-hidden=true href=#setting-up-the-raspberry-pi>#</a></h3><p>There are different ways to avoid having to retype the password everytime
when tranferring an application to the Raspberry Pi or running an application
remotely. On Linux, you can use <code>sshpass</code> for this.</p><p>The most easiest way and the one I recommend is to install your SSH key
on the Raspberry Pi with <code>ssh-copy-id</code>. This works on Linux and Windows.
You can follow the steps specified <a href=https://www.ssh.com/academy/ssh/copy-id>here</a> to do this.</p><p>Another way is to use a SSH key file by supplying the <code>-f SSHFILE</code> flag
to the <code>bld-deploy-remote.py</code> application in your <code>.cargo/config.toml</code>
or as an environmental variable <code>SSHPASS</code> with the <code>-e</code> flag.</p><h3 id=setup-linux>Setup Linux<a hidden class=anchor aria-hidden=true href=#setup-linux>#</a></h3><p>You can create a cross-compiler built with crosstool-ng
from <a href="https://www.dropbox.com/sh/hkn4lw87zr002fh/AAAO-HxFQzfmmPQQ9KVmoooGa?dl=0">here</a>. There is one
available for the Raspberry Pi 3 and the Raspberry Pi 4.</p><p>Following command should get the job done, assuming you
installed the cross-compiler shown above into the <code>$HOME/x-tools</code> folder:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>export</span> <span class=nv>PATH</span><span class=o>=</span><span class=nv>$PATH</span>:<span class=s2>&#34;</span><span class=nv>$HOME</span><span class=s2>/x-tools/armv8-rpi4-linux-gnueabihf/bin&#34;</span>
</span></span></code></pre></div><p>You can also put this in a script named <code>rpi4-path.sh</code> and source it
with <code>. rpi4-path.sh</code> or your can put it in your <code>.bashrc</code> file to add it
to <code>$PATH</code> permanently.</p><p>Test with <code>armv8-rpi4-linux-gnueabihf-gcc --version</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=go>[Raspberry Pi 4] rmueller@power-pinguin:~/Rust$ armv8-rpi4-linux-gnueabihf-gcc --version
</span></span></span><span class=line><span class=cl><span class=go>armv8-rpi4-linux-gnueabihf-gcc (crosstool-NG 1.24.0.390_62e9db2) 8.5.0
</span></span></span><span class=line><span class=cl><span class=go>Copyright (C) 2018 Free Software Foundation, Inc.
</span></span></span><span class=line><span class=cl><span class=go>This is free software; see the source for copying conditions.  There is NO
</span></span></span><span class=line><span class=cl><span class=go>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</span></span></span></code></pre></div><p>Proceed with the generic setup.</p><h3 id=setup-windows>Setup Windows<a hidden class=anchor aria-hidden=true href=#setup-windows>#</a></h3><p>It is recommended to install the cross-toolchain provided by
<a href=https://gnutoolchains.com/raspberry/>SysProgs</a>.</p><p>Add the binary path of your installed cross-toolchain for your path.</p><p>You can add the toolchain binary path to your system environmental variables
permanently, for example like shown here:</p><center><figure><img loading=lazy src=/img/rpi-rs-crosscompile/win-path.png alt="Windows Environmental Variables Example"><figcaption><p>Windows Environmental Variables Example</p></figcaption></figure></center><p>If you use <code>git bash</code>, you can also use the Linux way shown above.
Test with <code>arm-linux-gnueabihf-gcc --version</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ps data-lang=ps><span class=line><span class=cl><span class=nf>C:\Users\Robin\Documents\Rust\rpi-rs-crosscompile</span> <span class=p>[</span><span class=nf>main</span> <span class=nf>≡</span><span class=p>]&gt;</span> <span class=nf>arm-linux-gnueabihf-gcc</span> <span class=nf>--version</span>
</span></span><span class=line><span class=cl><span class=nf>arm-linux-gnueabihf-gcc.exe</span> <span class=s>(Raspbian 8.3.0-6+rpi1)</span> <span class=nf>8.3.0</span>
</span></span><span class=line><span class=cl><span class=nf>Copyright</span> <span class=s>(C)</span> <span class=mf>2018</span> <span class=nf>Free</span> <span class=nf>Software</span> <span class=nf>Foundation,</span> <span class=nf>Inc.</span>
</span></span><span class=line><span class=cl><span class=nf>This</span> <span class=nf>is</span> <span class=nf>free</span> <span class=nf>software;</span> <span class=nf>see</span> <span class=nf>the</span> <span class=nf>source</span> <span class=nf>for</span> <span class=nf>copying</span> <span class=nf>conditions.</span>  <span class=nf>There</span> <span class=nf>is</span> <span class=nf>NO</span>
</span></span><span class=line><span class=cl><span class=nf>warranty;</span> <span class=nf>not</span> <span class=nf>even</span> <span class=nf>for</span> <span class=nf>MERCHANTABILITY</span> <span class=nf>or</span> <span class=nf>FITNESS</span> <span class=nf>FOR</span> <span class=nf>A</span> <span class=nf>PARTICULAR</span> <span class=nf>PURPOSE.</span>
</span></span></code></pre></div><p>Proceed with the generic setup.</p><h3 id=generic-setup>Generic Setup<a hidden class=anchor aria-hidden=true href=#generic-setup>#</a></h3><p>Now you are ready to build the first application for the Raspberry Pi.
The <code>.cargo/def-config.toml</code> file is a template for a Cargo configuration
to perform flashing conveniently. Copy it to <code>.cargo/config.toml</code> first:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>cd</span> .cargo
</span></span><span class=line><span class=cl>cp def-config.toml config.toml
</span></span></code></pre></div><p>Then open the <code>config.toml</code> with a text editor of your choice and select
the correct linker first, for example with <code>armv8-rpi4-linux-gnueabihf-gcc</code> on Linux or
<code>arm-linux-gnueabihf-gcc</code> on Windows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=c># If you use a different cross-compiler, adapt this flag accordingly.</span>
</span></span><span class=line><span class=cl><span class=c># linker = &#34;armv8-rpi4-linux-gnueabihf-gcc&#34;</span>
</span></span><span class=line><span class=cl><span class=c># linker = &#34;arm-linux-gnueabihf-gcc&#34;</span>
</span></span><span class=line><span class=cl><span class=c># linker = &#34;arm-none-linux-gnueabihf-gcc&#34;</span>
</span></span></code></pre></div><p>Then select the correct runner to run the application instead of debugging it. For Windows,
select a runner using <code>py</code>.</p><p><strong>Linux</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=c># Requires Python3 installation. Takes care of transferring and running the application</span>
</span></span><span class=line><span class=cl><span class=c># to the Raspberry Pi</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;py bld-deploy-remote.py -t -r --source&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>runner</span> <span class=p>=</span> <span class=s2>&#34;python3 bld-deploy-remote.py -t -r --source&#34;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;py bld-deploy-remote.py -t -d --source&#34;</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;python3 bld-deploy-remote.py -t -d --source&#34;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;py bld-deploy-remote.py -t -d -s --gdb arm-linux-gnueabihf-gdb --source&#34;</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;python3 bld-deploy-remote.py -t -d --source&#34;</span>
</span></span></code></pre></div><p><strong>Windows</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=c># Requires Python3 installation. Takes care of transferring and running the application</span>
</span></span><span class=line><span class=cl><span class=c># to the Raspberry Pi</span>
</span></span><span class=line><span class=cl><span class=nx>runner</span> <span class=p>=</span> <span class=s2>&#34;py bld-deploy-remote.py -t -r --source&#34;</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;python3 bld-deploy-remote.py -t -r --source&#34;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;py bld-deploy-remote.py -t -d --source&#34;</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;python3 bld-deploy-remote.py -t -d --source&#34;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;py bld-deploy-remote.py -t -d -s --gdb arm-linux-gnueabihf-gdb --source&#34;</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;python3 bld-deploy-remote.py -t -d --source&#34;</span>
</span></span></code></pre></div><p>Finally select the correct builder depending on whether you have a Raspberry Pi 0/1
or a Raspberry Pi 2/3/4</p><h3 id=building-the-application>Building the application<a hidden class=anchor aria-hidden=true href=#building-the-application>#</a></h3><p>Everything should be ready to build the application.
Simply use <code>cargo build</code>.</p><h3 id=running-the-application>Running the application<a hidden class=anchor aria-hidden=true href=#running-the-application>#</a></h3><p>Everything should be ready to run the application remotely now.
Running the application is very simple now: Use <code>cargo run</code>, which will also build the application
automatically:</p><p><strong>Linux</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=go>[Raspberry Pi 4] rmueller@power-pinguin:~/Rust/rpi-rs-crosscompile(main)$ cargo run
</span></span></span><span class=line><span class=cl><span class=go>    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
</span></span></span><span class=line><span class=cl><span class=go>     Running `python3 bld-deploy-remote.py -t -r --source target/armv7-unknown-linux-gnueabihf/debug/rpi-rs-crosscompile`
</span></span></span><span class=line><span class=cl><span class=go>Running transfer command: sshpass  scp target/armv7-unknown-linux-gnueabihf/debug/rpi-rs-crosscompile pi@raspberrypi.local:&#34;/tmp/rpi-rs-crosscompile&#34;
</span></span></span><span class=line><span class=cl><span class=go>Running target application: sshpass  ssh pi@raspberrypi.local /tmp/rpi-rs-crosscompile
</span></span></span><span class=line><span class=cl><span class=go> __________________________
</span></span></span><span class=line><span class=cl><span class=go>&lt; Hello fellow Rustaceans! &gt;
</span></span></span><span class=line><span class=cl><span class=go> --------------------------
</span></span></span><span class=line><span class=cl><span class=go>        \
</span></span></span><span class=line><span class=cl><span class=go>         \
</span></span></span><span class=line><span class=cl><span class=go>            _~^~^~_
</span></span></span><span class=line><span class=cl><span class=go>        \) /  o o  \ (/
</span></span></span><span class=line><span class=cl><span class=go>          &#39;_   -   _&#39;
</span></span></span><span class=line><span class=cl><span class=go>          / &#39;-----&#39; \
</span></span></span></code></pre></div><p><strong>Windows</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=go>C:\Users\Robin\Documents\Rust\rpi-rs-crosscompile [main ≡]&gt; cargo run
</span></span></span><span class=line><span class=cl><span class=go>    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
</span></span></span><span class=line><span class=cl><span class=go>     Running `python3 bld-deploy-remote.py -t -r --source target\armv7-unknown-linux-gnueabihf\debug\rpi-rs-crosscompile`
</span></span></span><span class=line><span class=cl><span class=go>Running transfer command:  scp target\armv7-unknown-linux-gnueabihf\debug\rpi-rs-crosscompile pi@raspberrypi.local:&#34;/tmp/rpi-rs-crosscompile&#34;
</span></span></span><span class=line><span class=cl><span class=go>Warning: Permanently added the ED25519 host key for IP address &#39;...&#39; to the list of known hosts.
</span></span></span><span class=line><span class=cl><span class=go>rpi-rs-crosscompile                                                                   100% 4448KB  10.2MB/s   00:00
</span></span></span><span class=line><span class=cl><span class=go>Running target application:  ssh pi@raspberrypi.local /tmp/rpi-rs-crosscompile
</span></span></span><span class=line><span class=cl><span class=go>Warning: Permanently added the ED25519 host key for IP address &#39;...&#39; to the list of known hosts.
</span></span></span><span class=line><span class=cl><span class=go> __________________________
</span></span></span><span class=line><span class=cl><span class=go>&lt; Hello fellow Rustaceans! &gt;
</span></span></span><span class=line><span class=cl><span class=go> --------------------------
</span></span></span><span class=line><span class=cl><span class=go>        \
</span></span></span><span class=line><span class=cl><span class=go>         \
</span></span></span><span class=line><span class=cl><span class=go>            _~^~^~_
</span></span></span><span class=line><span class=cl><span class=go>        \) /  o o  \ (/
</span></span></span><span class=line><span class=cl><span class=go>          &#39;_   -   _&#39;
</span></span></span><span class=line><span class=cl><span class=go>          / &#39;-----&#39; \
</span></span></span></code></pre></div><p>As you can see, all commands executed by the Python scripts are shown as well.</p><h2 id=debugging-the-application-on-the-command-line>Debugging the application on the Command Line<a hidden class=anchor aria-hidden=true href=#debugging-the-application-on-the-command-line>#</a></h2><p>You can switch to the debugging configuration by changing the runner accordingly</p><p><strong>Linux</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=c># Requires Python3 installation. Takes care of transferring and running the application</span>
</span></span><span class=line><span class=cl><span class=c># to the Raspberry Pi</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;py bld-deploy-remote.py -t -r --source&#34;</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;python3 bld-deploy-remote.py -t -r --source&#34;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;py bld-deploy-remote.py -t -d --source&#34;</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;python3 bld-deploy-remote.py -t -d --source&#34;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;py bld-deploy-remote.py -t -d -s --gdb arm-linux-gnueabihf-gdb --source&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>runner</span> <span class=p>=</span> <span class=s2>&#34;python3 bld-deploy-remote.py -t -d --source&#34;</span>
</span></span></code></pre></div><p>Console output:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=go>[Raspberry Pi 4] rmueller@power-pinguin:~/Rust/rpi-rs-crosscompile(main)$ cargo run
</span></span></span><span class=line><span class=cl><span class=go>    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
</span></span></span><span class=line><span class=cl><span class=go>     Running `python3 bld-deploy-remote.py -t -d -s --source target/armv7-unknown-linux-gnueabihf/debug/rpi-rs-crosscompile`
</span></span></span><span class=line><span class=cl><span class=go>Running transfer command: sshpass  scp target/armv7-unknown-linux-gnueabihf/debug/rpi-rs-crosscompile pi@raspberrypi.local:&#34;/tmp/rpi-rs-crosscompile&#34;
</span></span></span><span class=line><span class=cl><span class=go>Running debug command: sshpass  ssh -f -L 17777:localhost:17777 pi@raspberrypi.local &#34;sh -c &#39;killall -q gdbserver; gdbserver *:17777 /tmp/rpi-rs-crosscompile&#39;&#34;
</span></span></span><span class=line><span class=cl><span class=go>Process /tmp/rpi-rs-crosscompile created; pid = 7343
</span></span></span><span class=line><span class=cl><span class=go>Listening on port 17777
</span></span></span><span class=line><span class=cl><span class=go>Running start command: gdb-multiarch -q -x gdb.gdb target/armv7-unknown-linux-gnueabihf/debug/rpi-rs-crosscompile
</span></span></span><span class=line><span class=cl><span class=go>Reading symbols from target/armv7-unknown-linux-gnueabihf/debug/rpi-rs-crosscompile...
</span></span></span><span class=line><span class=cl><span class=go>warning: Missing auto-load script at offset 0 in section .debug_gdb_scripts
</span></span></span><span class=line><span class=cl><span class=go>of file /home/rmueller/Rust/rpi-rs-crosscompile/target/armv7-unknown-linux-gnueabihf/debug/rpi-rs-crosscompile.
</span></span></span><span class=line><span class=cl><span class=go>Use `info auto-load python-scripts [REGEXP]` to list them.
</span></span></span><span class=line><span class=cl><span class=go>Remote debugging from host 127.0.0.1
</span></span></span><span class=line><span class=cl><span class=go>Reading /lib/ld-linux-armhf.so.3 from remote target...
</span></span></span><span class=line><span class=cl><span class=go>warning: File transfers from remote targets can be slow. Use &#34;set sysroot&#34; to access files locally instead.
</span></span></span><span class=line><span class=cl><span class=go>Reading /lib/ld-linux-armhf.so.3 from remote target...
</span></span></span><span class=line><span class=cl><span class=go>...
</span></span></span><span class=line><span class=cl><span class=go>0xb6fcea30 in ?? () from target:/lib/ld-linux-armhf.so.3
</span></span></span><span class=line><span class=cl><span class=go>Breakpoint 1 at 0x40ce70: main. (2 locations)
</span></span></span><span class=line><span class=cl><span class=go>Reading /usr/lib/arm-linux-gnueabihf/libarmmem-v7l.so from remote target...
</span></span></span><span class=line><span class=cl><span class=go>...
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>Breakpoint 1, 0x0040cf48 in main ()
</span></span></span><span class=line><span class=cl><span class=go>(gdb) c
</span></span></span><span class=line><span class=cl><span class=go>Continuing.
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>Breakpoint 1, rpi_rs_crosscompile::main () at src/main.rs:5
</span></span></span><span class=line><span class=cl><span class=go>5       let out = b&#34;Hello fellow Rustaceans!&#34;;
</span></span></span><span class=line><span class=cl><span class=go>(gdb) c
</span></span></span><span class=line><span class=cl><span class=go>Continuing.
</span></span></span><span class=line><span class=cl><span class=go> __________________________
</span></span></span><span class=line><span class=cl><span class=go>&lt; Hello fellow Rustaceans! &gt;
</span></span></span><span class=line><span class=cl><span class=go> --------------------------
</span></span></span><span class=line><span class=cl><span class=go>        \
</span></span></span><span class=line><span class=cl><span class=go>         \
</span></span></span><span class=line><span class=cl><span class=go>            _~^~^~_
</span></span></span><span class=line><span class=cl><span class=go>        \) /  o o  \ (/
</span></span></span><span class=line><span class=cl><span class=go>          &#39;_   -   _&#39;
</span></span></span><span class=line><span class=cl><span class=go>          / &#39;-----&#39; \
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>Child exited with status 0
</span></span></span><span class=line><span class=cl><span class=go>[Inferior 1 (process 7343) exited normally]
</span></span></span><span class=line><span class=cl><span class=go>(gdb) 
</span></span></span></code></pre></div><p><strong>Windows</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=c># Requires Python3 installation. Takes care of transferring and running the application</span>
</span></span><span class=line><span class=cl><span class=c># to the Raspberry Pi</span>
</span></span><span class=line><span class=cl><span class=nx>runner</span> <span class=p>=</span> <span class=s2>&#34;py bld-deploy-remote.py -t -r --source&#34;</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;python3 bld-deploy-remote.py -t -r --source&#34;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;py bld-deploy-remote.py -t -d --source&#34;</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;python3 bld-deploy-remote.py -t -d --source&#34;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=nx>runner</span> <span class=p>=</span> <span class=s2>&#34;py bld-deploy-remote.py -t -d -s --gdb arm-linux-gnueabihf-gdb --source&#34;</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;python3 bld-deploy-remote.py -t -d --source&#34;</span>
</span></span></code></pre></div><p>Now, you can use <code>cargo run</code> like before, but this time the Python helper program will
start a GDB server on the Pi and then launch a GDB application locally to debug the program.</p><p>Console Output, using <code>git bash</code> here with <code>scp</code> and <code>ssh</code> installed via MinGW64:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=go>Robin@DESKTOP-7KSTH01 MSYS ~/Documents/Rust/rpi-rs-crosscompile (main)
</span></span></span><span class=line><span class=cl><span class=go></span><span class=gp>$</span> cargo run
</span></span><span class=line><span class=cl><span class=go>    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
</span></span></span><span class=line><span class=cl><span class=go>     Running `py bld-deploy-remote.py -t -d -s --gdb arm-linux-gnueabihf-gdb --source &#39;target\armv7-unknown-linux-gnueabihf\debug\rpi-rs-crosscompile&#39;`
</span></span></span><span class=line><span class=cl><span class=go>Running transfer command:  scp target\armv7-unknown-linux-gnueabihf\debug\rpi-rs-crosscompile pi@raspberrypi.local:&#34;/tmp/rpi-rs-crosscompile&#34;
</span></span></span><span class=line><span class=cl><span class=go>Enter passphrase for key &#39;/c/Users/Robin/.ssh/id_rsa&#39;:
</span></span></span><span class=line><span class=cl><span class=go>target\armv7-unknown-linux-gnueabihf\debug\rpi-rs-crosscompile                        100% 4448KB   5.4MB/s   00:00
</span></span></span><span class=line><span class=cl><span class=go>Running debug command:  ssh -f -L 17777:localhost:17777 pi@raspberrypi.local &#34;sh -c &#39;killall -q gdbserver; gdbserver *:17777 /tmp/rpi-rs-crosscompile&#39;&#34;
</span></span></span><span class=line><span class=cl><span class=go>Enter passphrase for key &#39;/c/Users/Robin/.ssh/id_rsa&#39;:
</span></span></span><span class=line><span class=cl><span class=go>Process /tmp/rpi-rs-crosscompile created; pid = 29621
</span></span></span><span class=line><span class=cl><span class=go>Listening on port 17777
</span></span></span><span class=line><span class=cl><span class=go>Running start command: arm-linux-gnueabihf-gdb -q -x gdb.gdb target\armv7-unknown-linux-gnueabihf\debug\rpi-rs-crosscompile
</span></span></span><span class=line><span class=cl><span class=go>Reading symbols from target\armv7-unknown-linux-gnueabihf\debug\rpi-rs-crosscompile...done.
</span></span></span><span class=line><span class=cl><span class=go>warning: Unsupported auto-load script at offset 0 in section .debug_gdb_scripts
</span></span></span><span class=line><span class=cl><span class=go>of file C:\Users\Robin\Documents\Rust\rpi-rs-crosscompile\target\armv7-unknown-linux-gnueabihf\debug\rpi-rs-crosscompile.
</span></span></span><span class=line><span class=cl><span class=go>Use `info auto-load python-scripts [REGEXP]` to list them.
</span></span></span><span class=line><span class=cl><span class=go>Remote debugging from host 127.0.0.1
</span></span></span><span class=line><span class=cl><span class=go>0xb6fcea30 in ?? () from c:\sysgcc\raspberry\arm-linux-gnueabihf\sysroot/lib/ld-linux-armhf.so.3
</span></span></span><span class=line><span class=cl><span class=go>Breakpoint 1 at 0x40a7e4
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>Breakpoint 1, 0x0040a7e4 in main ()
</span></span></span><span class=line><span class=cl><span class=go>(gdb) b 6
</span></span></span><span class=line><span class=cl><span class=go>Breakpoint 2 at 0x40a718: file src\main.rs, line 6.
</span></span></span><span class=line><span class=cl><span class=go>(gdb) c
</span></span></span><span class=line><span class=cl><span class=go>Continuing.
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>Breakpoint 2, rpi_rs_crosscompile::main () at src\main.rs:6
</span></span></span><span class=line><span class=cl><span class=go>6           let width = 24;
</span></span></span><span class=line><span class=cl><span class=go>(gdb) s
</span></span></span><span class=line><span class=cl><span class=go>8           let mut writer = BufWriter::new(stdout());
</span></span></span><span class=line><span class=cl><span class=go>(gdb) c
</span></span></span><span class=line><span class=cl><span class=go>Continuing.
</span></span></span><span class=line><span class=cl><span class=go> __________________________
</span></span></span><span class=line><span class=cl><span class=go>&lt; Hello fellow Rustaceans! &gt;
</span></span></span><span class=line><span class=cl><span class=go> --------------------------
</span></span></span><span class=line><span class=cl><span class=go>        \
</span></span></span><span class=line><span class=cl><span class=go>         \
</span></span></span><span class=line><span class=cl><span class=go>            _~^~^~_
</span></span></span><span class=line><span class=cl><span class=go>        \) /  o o  \ (/
</span></span></span><span class=line><span class=cl><span class=go>          &#39;_   -   _&#39;
</span></span></span><span class=line><span class=cl><span class=go>          / &#39;-----&#39; \
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>Child exited with status 0
</span></span></span><span class=line><span class=cl><span class=go>[Inferior 1 (process 29621) exited normally]
</span></span></span><span class=line><span class=cl><span class=go>(gdb)
</span></span></span></code></pre></div><h2 id=debugging-the-application-with-vs-code-and-codelldb>Debugging the application with VS Code and <code>CodeLLDB</code><a hidden class=anchor aria-hidden=true href=#debugging-the-application-with-vs-code-and-codelldb>#</a></h2><p>I think the best debugging experience is still provided by GUI tools like Eclipse or VS Code.
The following examples are shown for Linux. The second one should work for Windows as well,
but I had issues getting the first configuration to work on Windows.</p><h3 id=gdb-server-started-by-vs-code>GDB server started by VS Code<a hidden class=anchor aria-hidden=true href=#gdb-server-started-by-vs-code>#</a></h3><p>Unfortunately, I have not found a way to get the debug output produced by an application
when starting the GDB server with VS code. Feel free to investigate how this could be solved
using VS Code tasks.</p><p>You can simply select and run the <code>Remote Debugging With Server</code> configuration
in VS Code. The result should look something like the following:</p><center><figure><img loading=lazy src=/img/rpi-rs-crosscompile/debug-vscode-with-server.png alt="Debugging with VS Code with GDB Server started by VS Code"><figcaption><p>Debugging with VS Code with GDB Server started by VS Code</p></figcaption></figure></center><h3 id=gdb-server-started-externally>GDB server started externally<a hidden class=anchor aria-hidden=true href=#gdb-server-started-externally>#</a></h3><p>The only difference is that the GDB server is now started in an external shell
instance, which also allows to see debug output produced by the application.
Configuring <code>.cargo/config.toml</code> correctly allows simply using <code>cargo run</code> to start the GDB server:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=c># Requires Python3 installation. Takes care of transferring and running the application</span>
</span></span><span class=line><span class=cl><span class=c># to the Raspberry Pi</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;py bld-deploy-remote.py -t -r --source&#34;</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;python3 bld-deploy-remote.py -t -r --source&#34;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;py bld-deploy-remote.py -t -d --source&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>runner</span> <span class=p>=</span> <span class=s2>&#34;python3 bld-deploy-remote.py -t -d --source&#34;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;py bld-deploy-remote.py -t -d -s --gdb arm-linux-gnueabihf-gdb --source&#34;</span>
</span></span><span class=line><span class=cl><span class=c># runner = &#34;python3 bld-deploy-remote.py -t -d --source&#34;</span>
</span></span></code></pre></div><p>After using <code>cargo run</code>, you can run the <code>Remote Debugging External Server</code>
configuration in VS Code. The result should look something like the following:</p><center><figure><img loading=lazy src=/img/rpi-rs-crosscompile/debug-vscode-external-server.png alt="Debugging with VS Code with externally started GDB server"><figcaption><p>Debugging with VS Code with externally started GDB server</p></figcaption></figure></center><h2 id=under-the-hood>Under the hood<a hidden class=anchor aria-hidden=true href=#under-the-hood>#</a></h2><p>If you&rsquo;re interested how exactly this is done in VS Code, you can have a look at the
<a href=https://github.com/robamu-org/rpi-rs-crosscompile/blob/main/.vscode/launch.json><code>launch.json</code></a>
and <a href=https://github.com/robamu-org/rpi-rs-crosscompile/blob/main/.vscode/tasks.json><code>tasks.json</code></a>
provided in the <a href=https://github.com/robamu-org/rpi-rs-crosscompile/tree/main/.vscode>template repository</a>.</p><p>These generally call the <code>bld-deploy-remote.py</code> script, which can be found
<a href=https://github.com/robamu-org/rpi-rs-crosscompile/blob/main/bld-deploy-remote.py>here</a>.
This script automates one to all of the following steps which are generally required to deploy and
debug a cross-compiled application:</p><ol><li>Build the application. When using a Cargo runner, Cargo will take care of this step</li><li>Transfer the application to the Raspberry Pi using the <code>-t</code> flag. The default destination
is the <code>/tmp</code> folder, but this can be customized with the <code>--dest</code> flag</li><li>Start the <code>gdbserver</code> on the Raspberry Pi. The script also sets up port forwarding on the port
17777 so that the development host can simply connect to <code>localhost:17777</code></li><li>Start the GDB application to debug the software</li></ol><p>Using Python instead of a shell script to perform these steps provides a little bit more flexiblity
and portability in my opinion. It also makes it easier to adapt the script to custom requirements,
because Python has the most easiest and most readable syntax of all automation tools I have
worked with.</p><p>This script can also be easily ported to other Embedded Linux board by tweaking the
<code>DEFAULT_*</code> parameters found at the top of the Python script.</p><h2 id=room-for-improvements>Room for Improvements<a hidden class=anchor aria-hidden=true href=#room-for-improvements>#</a></h2><p>I have not really looked into how tools like <a href=https://github.com/rust-embedded/cross><code>cross</code></a>
could be used to simplify this process. I think some steps might become easier but using <code>cross</code>
also requires <code>docker</code>. I think the ways to run and deploy cross-compiled software shown here
are sufficient for most use-cases. I might try out cross in the future though.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://robamu.github.io/tags/rust/>rust</a></li><li><a href=https://robamu.github.io/tags/cross-compile/>cross-compile</a></li><li><a href=https://robamu.github.io/tags/vscode/>vscode</a></li><li><a href=https://robamu.github.io/tags/cli/>cli</a></li><li><a href=https://robamu.github.io/tags/raspberrypi/>raspberrypi</a></li></ul></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-robamu-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2023 <a href=https://robamu.github.io>Robins blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>